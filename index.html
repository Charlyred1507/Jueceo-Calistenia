<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Detector de Movimiento Calistenia</title>
<style>
  body {
    margin: 0;
    background: #111;
    color: #fff;
    font-family: 'Poppins', sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    overflow: hidden;
  }
  video, canvas {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100%;
    height: auto;
    max-height: 100vh;
    border-radius: 12px;
    object-fit: cover;
  }
  #status {
    position: absolute;
    bottom: 20px;
    background: rgba(0,0,0,0.7);
    padding: 10px 20px;
    border-radius: 8px;
    font-size: 1rem;
    z-index: 10;
    max-width: 90%;
    text-align: center;
  }
  #startBtn {
    position: absolute;
    top: 20px;
    background: #28a745;
    border: none;
    color: white;
    padding: 12px 24px;
    border-radius: 8px;
    font-size: 1rem;
    cursor: pointer;
    z-index: 10;
  }
  #exerciseSelect {
    position: absolute;
    top: 70px;
    background: #222;
    border: none;
    color: white;
    padding: 8px 16px;
    border-radius: 8px;
    font-size: 1rem;
    z-index: 10;
  }
  #counter {
    position: absolute;
    top: 120px;
    font-size: 1.5rem;
    background: rgba(0,0,0,0.7);
    padding: 8px 16px;
    border-radius: 8px;
    z-index: 10;
  }
</style>
</head>
<body>

<button id="startBtn">Activar C√°mara</button>
<select id="exerciseSelect">
  <option value="pushup">Push-ups</option>
  <option value="dip">Fondos</option>
  <option value="squat">Squats</option>
  <option value="pullup">Pull-ups</option>
</select>
<div id="counter">Reps: 0</div>

<video id="video" playsinline autoplay muted></video>
<canvas id="output"></canvas>
<div id="status">Esperando c√°mara...</div>

<!-- TensorFlow.js -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.17.0"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>

<script>
const video = document.getElementById('video');
const canvas = document.getElementById('output');
const ctx = canvas.getContext('2d');
const statusEl = document.getElementById('status');
const startBtn = document.getElementById('startBtn');
const exerciseSelect = document.getElementById('exerciseSelect');
const counterEl = document.getElementById('counter');

let detector;
let reps = 0, up = false;
let currentExercise = exerciseSelect.value;
let lastNoRep = ""; // üëà para no repetir mensajes "no rep" id√©nticos

exerciseSelect.addEventListener('change', ()=>{
  currentExercise = exerciseSelect.value;
  reps = 0;
  up = false;
  counterEl.textContent = "Reps: 0";
  statusEl.textContent = `Ejercicio seleccionado: ${currentExercise}`;
});

startBtn.addEventListener('click', initCamera);

async function initCamera() {
  statusEl.textContent = "Iniciando c√°mara...";
  startBtn.disabled = true;
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
    video.srcObject = stream;
    await new Promise(res => video.onloadedmetadata = res);
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    statusEl.textContent = "C√°mara activa ‚úÖ";
    await initDetector();
    detectPose();
  } catch(err) {
    console.error(err);
    statusEl.textContent = "‚ùå No se pudo acceder a la c√°mara";
    startBtn.disabled = false;
  }
}

async function initDetector() {
  statusEl.textContent = "Cargando detector...";
  detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, {
    modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING
  });
  statusEl.textContent = "Detector activo ‚úÖ";
}

function getAngle(a,b,c){
  const AB = {x:b.x-a.x, y:b.y-a.y};
  const CB = {x:b.x-c.x, y:b.y-c.y};
  const dot = AB.x*CB.x + AB.y*CB.y;
  const magAB = Math.sqrt(AB.x**2 + AB.y**2);
  const magCB = Math.sqrt(CB.x**2 + CB.y**2);
  return Math.round(Math.acos(dot/(magAB*magCB))*180/Math.PI);
}

function setNoRep(message){
  if(message !== lastNoRep){
    statusEl.textContent = `‚ùå No rep ‚Äì ${message}`;
    lastNoRep = message;
  }
}

// ----------------------
// üîç DETECCI√ìN DE REPS
// ----------------------
function detectReps(kp){
  let angle=0;
  let valid = false;

  // ---------- PUSHUPS ----------
  if(currentExercise==="pushup"){
    const shoulder = kp[11], elbow = kp[13], wrist = kp[15];
    const hip = kp[23], knee = kp[25];
    if(shoulder && elbow && wrist && hip && knee){
      angle = getAngle(shoulder, elbow, wrist);
      const bodyLine = getAngle(shoulder, hip, knee);

      if(angle < 90 && !up) up = true;
      if(angle > 165 && up){
        if(bodyLine < 160){ setNoRep("Cuerpo no alineado (cadera baja o alta)"); }
        else { reps++; valid = true; }
        up = false;
      }
    }

  // ---------- DIPS ----------
  } else if(currentExercise==="dip"){
    const shoulder = kp[11], elbow = kp[13], wrist = kp[15];
    if(shoulder && elbow && wrist){
      angle = getAngle(shoulder, elbow, wrist);
      if(angle < 90 && !up) up = true;
      if(angle > 160 && up){
        if(angle > 180 || angle < 70){ setNoRep("Rango incompleto de codo"); }
        else { reps++; valid = true; }
        up = false;
      }
    }

  // ---------- SQUATS ----------
  } else if(currentExercise==="squat"){
    const hip = kp[23], knee = kp[25], ankle = kp[27];
    if(hip && knee && ankle && hip.score>0.4 && knee.score>0.4 && ankle.score>0.4){
      angle = getAngle(hip, knee, ankle);
      if(angle < 90 && !up) up = true;
      if(angle > 165 && up){
        if(angle > 180 || angle < 70){ setNoRep("No baj√≥ suficiente (cadera no al nivel de rodillas)"); }
        else { reps++; valid = true; }
        up = false;
      }
    }

  // ---------- PULLUPS ----------
  } else if(currentExercise==="pullup"){
    const yNose = kp[0].y;
    const yHands = (kp[9].y + kp[10].y)/2;
    const shoulder = kp[11], elbow = kp[13], wrist = kp[15];
    if(yNose < yHands && !up) up = true;
    if(yNose > yHands + 80 && up){
      const elbowAngle = getAngle(shoulder, elbow, wrist);
      if(elbowAngle > 100){ setNoRep("Barbilla no super√≥ la barra"); }
      else { reps++; valid = true; }
      up = false;
    }
  }

  if(valid){
    counterEl.textContent = `Reps: ${reps}`;
    statusEl.textContent = `‚úÖ Rep v√°lida (${currentExercise})`;
    lastNoRep = "";
  }
}

function drawSkeleton(pose){
  const keypoints = pose.keypoints;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(video,0,0,canvas.width,canvas.height);

  const adjacentPairs = poseDetection.util.getAdjacentPairs(poseDetection.SupportedModels.MoveNet);
  ctx.lineWidth = 2;
  ctx.strokeStyle = "#00FF00";
  adjacentPairs.forEach(([i,j])=>{
    const kp1 = keypoints[i], kp2 = keypoints[j];
    if(kp1.score>0.4 && kp2.score>0.4){
      ctx.beginPath();
      ctx.moveTo(kp1.x,kp1.y);
      ctx.lineTo(kp2.x,kp2.y);
      ctx.stroke();
    }
  });

  keypoints.forEach(kp=>{
    if(kp.score>0.4){
      ctx.beginPath();
      ctx.arc(kp.x,kp.y,5,0,2*Math.PI);
      ctx.fillStyle="#00FF00";
      ctx.fill();
    }
  });

  detectReps(keypoints);
}

async function detectPose(){
  const detect = async ()=>{
    if(video.readyState>=2){
      const poses = await detector.estimatePoses(video);
      if(poses.length>0){
        drawSkeleton(poses[0]);
      } else {
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.drawImage(video,0,0,canvas.width,canvas.height);
      }
    }
    requestAnimationFrame(detect);
  };
  detect();
}
</script>
</body>
</html>