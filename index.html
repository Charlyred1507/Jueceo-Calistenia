<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Detector de Movimiento Calistenia (Optimizado)</title>
<style>
  body {
    margin: 0;
    background: #111;
    color: #fff;
    font-family: sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    overflow: hidden;
  }
  video, canvas {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100%;
    height: auto;
    max-height: 100vh;
    border-radius: 12px;
    object-fit: cover;
  }
  #ui-controls {
    position: absolute;
    top: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    z-index: 10;
  }
  #ui-controls > * {
    margin: 5px;
  }
  #status {
    position: absolute;
    bottom: 20px;
    background: rgba(255, 255, 255, 0.9);
    color: #111;
    padding: 10px 20px;
    border-radius: 8px;
    font-size: 1rem;
    font-weight: bold;
    z-index: 10;
    min-width: 200px;
    text-align: center;
  }
  #startBtn {
    background: #28a745;
    border: none;
    color: white;
    padding: 12px 24px;
    border-radius: 8px;
    font-size: 1rem;
    cursor: pointer;
  }
  #exerciseSelect {
    background: #222;
    border: 2px solid #fff;
    color: white;
    padding: 8px 16px;
    border-radius: 8px;
    font-size: 1rem;
  }
  #counter {
    font-size: 1.5rem;
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 8px 16px;
    border-radius: 8px;
  }
</style>
</head>
<body>

<div id="ui-controls">
  <button id="startBtn">Activar C√°mara</button>
  <select id="exerciseSelect">
    <option value="pushup">Push-ups</option>
    <option value="dip">Fondos</option>
    <option value="squat">Squats</option>
    <option value="pullup">Pull-ups</option>
  </select>
  <div id="counter">Reps: 0</div>
</div>

<video id="video" playsinline muted style="display:none;"></video>
<canvas id="output"></canvas>
<div id="status">Presiona 'Activar C√°mara' para comenzar.</div>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.17.0"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>

<script>
const video = document.getElementById('video');
const canvas = document.getElementById('output');
const ctx = canvas.getContext('2d');
const statusEl = document.getElementById('status');
const startBtn = document.getElementById('startBtn');
const exerciseSelect = document.getElementById('exerciseSelect');
const counterEl = document.getElementById('counter');

let detector;
let reps = 0, up = false;
let currentExercise = exerciseSelect.value;
let inPosition = false;
let feedbackMessage = "";
let feedbackTimer = null;
let movementBufferY = []; // Buffer para la quietud
let angleBuffer = {}; // Buffer para el suavizado de √°ngulo
const MIN_SCORE = 0.7; // Confianza m√≠nima para evitar detecciones fantasma
const SMOOTHING_FRAMES = 5; // Frames para el promedio m√≥vil

// --- Funciones de Utilidad ---

function showFeedback(msg, duration=1500){
  if(feedbackMessage !== msg || statusEl.textContent === ""){
    feedbackMessage = msg;
    statusEl.textContent = msg;
    if(feedbackTimer) clearTimeout(feedbackTimer);
    if(duration > 0){
        feedbackTimer = setTimeout(()=>{ feedbackMessage=""; statusEl.textContent=""; }, duration);
    }
  }
}

// Promedio M√≥vil para Suavizado
function getSmoothedAngle(exercise, angle) {
    if (!angleBuffer[exercise]) {
        angleBuffer[exercise] = [];
    }
    
    angleBuffer[exercise].push(angle);

    if (angleBuffer[exercise].length > SMOOTHING_FRAMES) {
        angleBuffer[exercise].shift();
    }

    if (angleBuffer[exercise].length < SMOOTHING_FRAMES) {
        return angle;
    }
    
    const sum = angleBuffer[exercise].reduce((a, b) => a + b, 0);
    return sum / angleBuffer[exercise].length;
}

// Calcula el √°ngulo (misma funci√≥n robusta)
function getAngle(a,b,c){
  if(!a || !b || !c) return 180;
  const AB = {x:b.x-a.x, y:b.y-a.y};
  const CB = {x:b.x-c.x, y:b.y-c.y};
  const dot = AB.x*CB.x + AB.y*CB.y;
  const magAB = Math.sqrt(AB.x**2 + AB.y**2);
  const magCB = Math.sqrt(CB.x**2 + CB.y**2);
  if(magAB*magCB === 0) return 180;
  let cosAngle = dot/(magAB*magCB);
  cosAngle = Math.max(-1, Math.min(1, cosAngle));
  return Math.round(Math.acos(cosAngle)*180/Math.PI);
}

// Estabilidad para Quietud (10px en 30 frames para inicio, 15px en 10 frames para conteo)
function isStable(y, threshold=10, frames=30){
  if(y === undefined) return false;
  movementBufferY.push(y);
  if(movementBufferY.length>frames) movementBufferY.shift();
  if(movementBufferY.length < frames) return false;
  return (Math.max(...movementBufferY)-Math.min(...movementBufferY))<threshold;
}

// --- Inicializaci√≥n y Bucle de Detecci√≥n (Sin cambios) ---

async function initDetector() {
    showFeedback("Cargando detector...", 0);
    detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, {
        modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING
    });
    showFeedback("Detector cargado.", 1000);
}

async function initCamera() {
    startBtn.disabled = true;
    showFeedback("Solicitando permisos de c√°mara...", 0);
    try {
        const stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: 'environment' },
            audio: false
        });
        video.srcObject = stream;
        
        await new Promise((resolve) => {
            video.onloadedmetadata = () => {
                resolve(video);
            };
        });

        video.width = video.videoWidth;
        video.height = video.videoHeight;
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        await video.play();

        showFeedback("C√°mara activa. Inicializando IA...", 0);
        await initDetector();
        detectPose();
    } catch(err) {
        console.error("Error al acceder a la c√°mara o iniciar:", err);
        showFeedback(`‚ùå ERROR: No se pudo iniciar la c√°mara.`, 0);
        startBtn.disabled = false;
    }
}

function drawSkeleton(pose){
    const keypoints = pose.keypoints;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(video,0,0,canvas.width,canvas.height);

    const adjacentPairs = poseDetection.util.getAdjacentPairs(poseDetection.SupportedModels.MoveNet);
    ctx.lineWidth=4;
    ctx.strokeStyle="#00FF00";
    adjacentPairs.forEach(([i,j])=>{
        const kp1=keypoints[i], kp2=keypoints[j];
        if(kp1.score>0.5 && kp2.score>0.5){
            ctx.beginPath();
            ctx.moveTo(kp1.x,kp1.y);
            ctx.lineTo(kp2.x,kp2.y);
            ctx.stroke();
        }
    });

    keypoints.forEach(kp=>{
        if(kp.score>0.5){
            ctx.beginPath();
            ctx.arc(kp.x,kp.y,6,0,2*Math.PI);
            ctx.fillStyle="#00FF00";
            ctx.fill();
        }
    });

    if(keypoints.length > 0) detectReps(keypoints);
}

async function detectPose(){
    const detect = async ()=>{
        if(video.readyState>=2 && detector){
            const poses = await detector.estimatePoses(video);
            if(poses.length>0) drawSkeleton(poses[0]);
            else ctx.drawImage(video,0,0,canvas.width,canvas.height);
        }
        requestAnimationFrame(detect);
    };
    detect();
}

// --- Detecci√≥n de Repeticiones con Suavizado (L√≥gica CLAVE) ---

function detectReps(kp){
  
  // 1. Mapeo de Keypoints
  const [nose, , , , , shoulderL, shoulderR, elbowL, elbowR, wristL, wristR, hipL, hipR, kneeL, kneeR, ankleL, ankleR] = kp;
  
  // Usamos el punto con mejor score
  const shoulder = shoulderR.score > shoulderL.score ? shoulderR : shoulderL;
  const elbow = elbowR.score > elbowL.score ? elbowR : elbowL;
  const wrist = wristR.score > wristL.score ? wristR : wristL;
  const hip = hipL.score > hipR.score ? hipL : hipR;
  const knee = kneeL.score > kneeR.score ? kneeL : kneeR;
  const ankle = ankleL.score > ankleR.score ? ankleL : ankleR;
  
  // 2. FILTRO DE CONFIANZA (Anti-fantasma)
  const mainScore = Math.max(shoulder.score, hip.score, nose.score);
  
  if (mainScore < MIN_SCORE) {
    inPosition = false;
    up = false;
    showFeedback("Esperando detecci√≥n de persona...", 0); 
    return;
  }

  // Punto de referencia Y para estabilidad
  const yAvg = hip.y; 
  if(yAvg) movementBufferY.push(yAvg);
  

  switch(currentExercise){
    case "pushup":
    case "dip":
      if(shoulder.score < MIN_SCORE || elbow.score < MIN_SCORE || wrist.score < MIN_SCORE) return;
      
      const rawAngle = getAngle(shoulder, elbow, wrist);
      const angle = getSmoothedAngle(currentExercise, rawAngle); // ‚û°Ô∏è USAR √ÅNGULO SUAVIZADO
      
      const targetAngle = (currentExercise === "pushup") ? 105 : 95; 
      const instruction = (currentExercise === "pushup") ? "Push-ups" : "Fondos";

      // Posici√≥n Inicial
      if(!inPosition){
        if(angle > 155 && isStable(yAvg, 10, 30)){
          inPosition = true;
          showFeedback(`üü¢ Listo para empezar ${instruction}`, 0);
        } else {
          showFeedback(`Col√≥cate en posici√≥n inicial: brazos extendidos (${instruction})`, 0);
        }
      } else {
        // Fase 1: Bajada/Flexi√≥n (Trigger)
        if(angle <= targetAngle && !up) { up = true; }
        
        // Fase 2: Subida y conteo (Requiere quietud en la posici√≥n extendida)
        if(angle >= 155 && up){
          if (isStable(yAvg, 15, 10)) { // ‚û°Ô∏è Estabilidad al final de la repetici√≥n
            reps++;
            up=false;
            showFeedback("‚úÖ Repetici√≥n v√°lida");
          }
        } else if(angle >= 155 && !up){
          showFeedback(`‚ùå No rep: No bajaste suficiente (necesitas <= ${targetAngle}¬∞)`, 0);
        }
      }
      break;

    case "squat":
      if(hip.score < MIN_SCORE || knee.score < MIN_SCORE || ankle.score < MIN_SCORE) return;
      
      const rawKneeAngle = getAngle(hip, knee, ankle);
      const kneeAngle = getSmoothedAngle(currentExercise, rawKneeAngle); // ‚û°Ô∏è USAR √ÅNGULO SUAVIZADO

      // Posici√≥n Inicial
      if(!inPosition){
        if(kneeAngle > 155 && isStable(yAvg, 10, 30)){
          inPosition = true;
          showFeedback("üü¢ Listo para empezar Squats", 0);
        } else {
          showFeedback("Col√≥cate en posici√≥n inicial: piernas rectas", 0);
        }
      } else {
        // Fase 1: Bajada (Trigger)
        if(kneeAngle <= 130 && !up) { up = true; }
        
        // Fase 2: Subida y conteo (Requiere quietud en la posici√≥n recta)
        if(kneeAngle >= 155 && up){
          if (isStable(yAvg, 15, 10)) { // ‚û°Ô∏è Estabilidad al final de la repetici√≥n
            reps++;
            up=false;
            showFeedback("‚úÖ Repetici√≥n v√°lida");
          }
        } else if(kneeAngle >= 155 && !up){
          showFeedback(`‚ùå No rep: No bajaste suficiente (necesitas <= 130¬∞)`, 0);
        }
      }
      break;

    case "pullup":
      if(nose.score < MIN_SCORE || wristL.score < MIN_SCORE || wristR.score < MIN_SCORE) return;
      
      const yHands = (wristL.y + wristR.y)/2;
      const yNose = nose.y;

      // Posici√≥n Inicial
      if(!inPosition){
        if(yNose > yHands + 80 && isStable(yAvg, 10, 30)){
          inPosition = true;
          showFeedback("üü¢ Listo para empezar Pull-ups", 0);
        } else {
          showFeedback("Col√≥cate en posici√≥n inicial: cuelga con brazos extendidos", 0);
        }
      } else {
        // L√≥gica Invertida (Subida/Bajada)
        
        // Fase 1: Subida (Trigger: Nariz al tope)
        if(yNose <= yHands && !up) { up = true; } 
        
        // Fase 2: Bajada y conteo (Se cuenta al regresar a colgado)
        if(yNose >= yHands + 80 && up){
          if (isStable(yAvg, 15, 10)) { // ‚û°Ô∏è Estabilidad al final de la repetici√≥n (Colgado)
            reps++;
            up=false;
            showFeedback("‚úÖ Repetici√≥n v√°lida");
          }
        } else if(yNose >= yHands + 80 && !up){
          showFeedback(`‚ùå No rep: No subiste suficiente (Nariz no alcanz√≥ el nivel de las manos)`, 0);
        }
      }
      break;
  }

  counterEl.textContent = `Reps: ${reps}`;
}

// --- Eventos ---

startBtn.addEventListener('click', initCamera);

exerciseSelect.addEventListener('change', ()=>{
  currentExercise = exerciseSelect.value;
  reps = 0;
  up = false;
  inPosition = false;
  movementBufferY = [];
  angleBuffer = {}; // ‚û°Ô∏è Resetear el buffer de suavizado
  counterEl.textContent = "Reps: 0";
  const exerciseName = exerciseSelect.options[exerciseSelect.selectedIndex].text;
  showFeedback(`Ejercicio seleccionado: ${exerciseName}`, 2000);
});
</script>
</body>
</html>
