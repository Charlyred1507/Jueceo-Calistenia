<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CalisJudge AI Visual</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose"></script>
  <style>
    body {
      margin: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      background: #0e0e0e;
      color: #fff;
      font-family: 'Segoe UI', sans-serif;
    }
    video, canvas {
      position: absolute;
      transform: scaleX(-1);
      border-radius: 10px;
    }
    select, h2, h3 {
      z-index: 2;
      margin-top: 10px;
    }
    #status {
      font-weight: bold;
      color: #ffcc00;
      font-size: 1.2em;
    }
  </style>
</head>
<body>
  <h2>üèãÔ∏è‚Äç‚ôÇÔ∏è CalisJudge AI Visual</h2>
  <select id="exercise">
    <option value="pushup">Push Ups</option>
    <option value="dip">Fondos</option>
    <option value="pullup">Pull Ups</option>
    <option value="squat">Squats</option>
  </select>
  <h3 id="counter">Reps: 0</h3>
  <h3 id="status">Esperando...</h3>

  <video id="video" width="640" height="480" autoplay muted playsinline></video>
  <canvas id="output" width="640" height="480"></canvas>

  <script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('output');
    const ctx = canvas.getContext('2d');
    const counterEl = document.getElementById('counter');
    const statusEl = document.getElementById('status');
    const exerciseSelect = document.getElementById('exercise');

    let detector, model, currentExercise = exerciseSelect.value;
    let reps = 0, phase = "ready";
    let angleBuffer = [];
    let lastNoRep = "", inMovement = false;
    let overlayColor = "#00ff88"; // verde por defecto

    async function initCamera() {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { width: 640, height: 480 }
      });
      video.srcObject = stream;
      await new Promise(r => video.onloadedmetadata = r);
    }

    async function initDetector() {
      model = poseDetection.SupportedModels.MoveNet;
      detector = await poseDetection.createDetector(model, { modelType: 'SinglePose.Lightning' });
    }

    function getAngle(a, b, c) {
      const ab = [a.x - b.x, a.y - b.y];
      const cb = [c.x - b.x, c.y - b.y];
      const dot = ab[0]*cb[0] + ab[1]*cb[1];
      const magA = Math.sqrt(ab[0]**2 + ab[1]**2);
      const magC = Math.sqrt(cb[0]**2 + cb[1]**2);
      const angle = Math.acos(dot / (magA * magC));
      return (angle * 180) / Math.PI;
    }

    function setNoRep(reason) {
      if (lastNoRep !== reason) {
        statusEl.textContent = `‚ùå No Rep: ${reason}`;
        overlayColor = "#ff4444";
        lastNoRep = reason;
      }
    }

    function setGoodRep() {
      statusEl.textContent = "‚úÖ Rep v√°lida";
      overlayColor = "#00ff88";
      lastNoRep = "";
    }

    function updateRepsDisplay() {
      counterEl.textContent = `Reps: ${reps}`;
    }

    function smoothAngle(angle) {
      angleBuffer.push(angle);
      if (angleBuffer.length > 5) angleBuffer.shift();
      return angleBuffer.reduce((a,b)=>a+b)/angleBuffer.length;
    }

    function detectExercise(pose) {
      const kp = pose.keypoints;
      const s = kp[11], e = kp[13], w = kp[15];
      const h = kp[23], k = kp[25], a = kp[27];
      if (!s || !e || !w || !h || !k || !a) return;

      let angle, depthAngle;

      switch(currentExercise) {
        case "pushup":
          angle = getAngle(s, e, w);
          depthAngle = getAngle(s, h, k);
          handlePhases(angle, depthAngle, 90, 160, 165, "Cuerpo no alineado");
          drawOverlay([s,e,w], angle);
          break;
        case "dip":
          angle = getAngle(s, e, w);
          handlePhases(angle, null, 85, 155, 160, null);
          drawOverlay([s,e,w], angle);
          break;
        case "pullup":
          angle = getAngle(s, e, w);
          handlePhases(angle, null, 70, 150, 160, null);
          drawOverlay([s,e,w], angle);
          break;
        case "squat":
          angle = getAngle(h, k, a);
          handlePhases(angle, null, 80, 160, 165, null);
          drawOverlay([h,k,a], angle);
          break;
      }
    }

    function handlePhases(angle, bodyLine, downThresh, startThresh, endThresh, alignMsg) {
      const smooth = smoothAngle(angle);

      if (phase === "ready" && smooth < startThresh) {
        inMovement = true;
        phase = "down";
      } 
      else if (phase === "down" && smooth < downThresh) {
        phase = "bottom";
      } 
      else if (phase === "bottom" && smooth > endThresh) {
        if (bodyLine && bodyLine < 160) {
          setNoRep(alignMsg || "Cuerpo no alineado");
        } else {
          reps++;
          setGoodRep();
        }
        updateRepsDisplay();
        phase = "ready";
        inMovement = false;
      } 
      else if (inMovement && phase === "down" && smooth > startThresh) {
        setNoRep("No baj√≥ suficiente antes de subir");
        phase = "ready";
        inMovement = false;
      }
    }

    function drawOverlay(points, angle) {
      if (points.length < 3) return;
      ctx.lineWidth = 5;
      ctx.strokeStyle = overlayColor;
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      ctx.lineTo(points[1].x, points[1].y);
      ctx.lineTo(points[2].x, points[2].y);
      ctx.stroke();

      ctx.fillStyle = overlayColor;
      ctx.font = "18px Arial";
      ctx.fillText(`${Math.round(angle)}¬∞`, points[1].x + 10, points[1].y - 10);
    }

    async function run() {
      const poses = await detector.estimatePoses(video);
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (poses.length > 0) {
        const pose = poses[0];
        detectExercise(pose);
      }

      requestAnimationFrame(run);
    }

    exerciseSelect.addEventListener("change", () => {
      currentExercise = exerciseSelect.value;
      reps = 0;
      phase = "ready";
      angleBuffer = [];
      lastNoRep = "";
      overlayColor = "#00ff88";
      statusEl.textContent = "Esperando...";
      updateRepsDisplay();
    });

    (async () => {
      await initCamera();
      await initDetector();
      run();
    })();
  </script>
</body>
</html>