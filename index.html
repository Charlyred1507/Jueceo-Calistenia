<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CalisJudge AI</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
  <style>
    body {
      margin: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      background: #0e0e0e;
      color: #fff;
      font-family: 'Poppins', sans-serif;
      overflow: hidden;
    }
    video, canvas {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scaleX(-1);
      border-radius: 10px;
      max-width: 100%;
      height: auto;
    }
    h2, select, h3 {
      z-index: 2;
      margin-top: 10px;
    }
    #status {
      font-weight: bold;
      color: #ffcc00;
      font-size: 1.2em;
    }
  </style>
</head>
<body>
  <h2>üèãÔ∏è‚Äç‚ôÇÔ∏è CalisJudge AI</h2>
  <select id="exercise">
    <option value="pushup">Push Ups</option>
    <option value="dip">Fondos</option>
    <option value="pullup">Pull Ups</option>
    <option value="squat">Squats</option>
  </select>
  <h3 id="counter">Reps: 0</h3>
  <h3 id="status">Esperando c√°mara...</h3>

  <video id="video" width="640" height="480" autoplay muted playsinline></video>
  <canvas id="output" width="640" height="480"></canvas>

  <script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('output');
    const ctx = canvas.getContext('2d');
    const counterEl = document.getElementById('counter');
    const statusEl = document.getElementById('status');
    const exerciseSelect = document.getElementById('exercise');

    let detector, currentExercise = exerciseSelect.value;
    let reps = 0, phase = "ready";
    let angleBuffer = [];
    let lastFeedback = "";
    let overlayColor = "#00ff88";

    // === Inicializar c√°mara ===
    async function initCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { width: 640, height: 480 }
        });
        video.srcObject = stream;
        await new Promise(r => video.onloadeddata = r);
        console.log("üé• C√°mara activa");
        statusEl.textContent = "C√°mara activa ‚úÖ";
      } catch (err) {
        console.error("Error al activar c√°mara", err);
        statusEl.textContent = "‚ùå No se pudo acceder a la c√°mara";
      }
    }

    // === Cargar modelo MoveNet ===
    async function initDetector() {
      statusEl.textContent = "Cargando detector...";
      detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, {
        modelType: 'SinglePose.Lightning'
      });
      statusEl.textContent = "Detector listo ‚úÖ";
    }

    // === Calcular √°ngulo entre tres puntos ===
    function getAngle(a, b, c) {
      if (!a || !b || !c) return 180;
      const ab = [a.x - b.x, a.y - b.y];
      const cb = [c.x - b.x, c.y - b.y];
      const dot = ab[0]*cb[0] + ab[1]*cb[1];
      const magA = Math.sqrt(ab[0]**2 + ab[1]**2);
      const magC = Math.sqrt(cb[0]**2 + cb[1]**2);
      const angle = Math.acos(dot / (magA * magC));
      return (angle * 180) / Math.PI;
    }

    // === Mostrar feedback ===
    function showFeedback(text, color = "#00ff88") {
      if (text !== lastFeedback) {
        statusEl.textContent = text;
        overlayColor = color;
        lastFeedback = text;
      }
    }

    function smoothAngle(angle) {
      angleBuffer.push(angle);
      if (angleBuffer.length > 5) angleBuffer.shift();
      return angleBuffer.reduce((a,b)=>a+b)/angleBuffer.length;
    }

    function detectExercise(pose) {
      const kp = pose.keypoints;
      const s = kp[11], e = kp[13], w = kp[15]; // hombro, codo, mu√±eca izq.
      const h = kp[23], k = kp[25], a = kp[27]; // cadera, rodilla, tobillo izq.
      if (!s || !e || !w || !h || !k || !a) return;

      let angle, feedback = "";

      switch(currentExercise) {
        case "pushup":
          angle = getAngle(s, e, w);
          handlePhases(angle, 85, 160, "pushup");
          drawOverlay([s,e,w], angle);
          break;

        case "dip":
          angle = getAngle(s, e, w);
          handlePhases(angle, 80, 155, "dip");
          drawOverlay([s,e,w], angle);
          break;

        case "pullup":
          const nose = kp[0], handY = (kp[9].y + kp[10].y) / 2;
          const diff = handY - nose.y;
          handleVertical(diff, 50, 120, "pullup");
          break;

        case "squat":
          angle = getAngle(h, k, a);
          handlePhases(angle, 85, 160, "squat");
          drawOverlay([h,k,a], angle);
          break;
      }
    }

    // === Para ejercicios de √°ngulo (pushup, dip, squat) ===
    function handlePhases(angle, downThresh, upThresh, type) {
      const smoothed = smoothAngle(angle);

      if (phase === "ready" && smoothed < downThresh) {
        phase = "down";
        showFeedback("‚¨áÔ∏è Bajando...", "#ffaa00");
      }
      else if (phase === "down" && smoothed < downThresh - 5) {
        showFeedback("‚úÖ Profundidad alcanzada", "#00ff88");
      }
      else if (phase === "down" && smoothed > upThresh) {
        reps++;
        counterEl.textContent = `Reps: ${reps}`;
        phase = "ready";
        showFeedback("‚úÖ Rep v√°lida", "#00ff88");
      }
      else if (phase === "down" && smoothed > downThresh && smoothed < upThresh - 20) {
        showFeedback("‚ùå No bajaste lo suficiente", "#ff4444");
      }
    }

    // === Para ejercicios verticales (pullup) ===
    function handleVertical(diff, topThresh, bottomThresh, type) {
      if (phase === "ready" && diff < topThresh) {
        phase = "up";
        showFeedback("‚¨ÜÔ∏è Subiendo...", "#ffaa00");
      } 
      else if (phase === "up" && diff < topThresh - 10) {
        showFeedback("‚úÖ Ment√≥n arriba", "#00ff88");
      }
      else if (phase === "up" && diff > bottomThresh) {
        reps++;
        counterEl.textContent = `Reps: ${reps}`;
        phase = "ready";
        showFeedback("‚úÖ Rep v√°lida", "#00ff88");
      }
      else if (phase === "up" && diff > topThresh && diff < bottomThresh - 30) {
        showFeedback("‚ùå No subiste lo suficiente", "#ff4444");
      }
    }

    // === Dibuja l√≠neas y √°ngulos ===
    function drawOverlay(points, angle) {
      if (points.length < 3) return;
      ctx.lineWidth = 5;
      ctx.strokeStyle = overlayColor;
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      ctx.lineTo(points[1].x, points[1].y);
      ctx.lineTo(points[2].x, points[2].y);
      ctx.stroke();

      ctx.fillStyle = overlayColor;
      ctx.font = "18px Arial";
      ctx.fillText(`${Math.round(angle)}¬∞`, points[1].x + 10, points[1].y - 10);
    }

    async function run() {
      const poses = await detector.estimatePoses(video);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      if (poses.length > 0) {
        detectExercise(poses[0]);
      }

      requestAnimationFrame(run);
    }

    exerciseSelect.addEventListener("change", () => {
      currentExercise = exerciseSelect.value;
      reps = 0;
      phase = "ready";
      counterEl.textContent = "Reps: 0";
      statusEl.textContent = "Ejercicio cambiado ‚úÖ";
      overlayColor = "#00ff88";
    });

    // === Secuencia principal ===
    (async () => {
      await initCamera();
      await initDetector();
      run();
    })();
  </script>
</body>
</html>