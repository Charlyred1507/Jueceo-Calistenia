<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>CalisJudge AI — Robust</title>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.17.0"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
<style>
  body { margin:0; background:#0f0f0f; color:#fff; font-family: Inter, Arial; display:flex; flex-direction:column; align-items:center; }
  #controls { z-index:3; margin-top:12px; display:flex; gap:12px; align-items:center; }
  select, button { padding:8px 12px; border-radius:8px; border:none; background:#222; color:#fff; }
  video, canvas { position: absolute; top:50%; left:50%; transform: translate(-50%, -50%) scaleX(-1); border-radius:12px; max-height:80vh; }
  #counter { position: absolute; right:20px; top:20px; background:rgba(0,0,0,0.6); padding:8px 12px; border-radius:8px; z-index:4; }
  #status { position: absolute; left:20px; bottom:20px; background:rgba(0,0,0,0.7); padding:8px 12px; border-radius:8px; z-index:4; max-width:45%; }
</style>
</head>
<body>
  <div id="controls">
    <select id="exercise">
      <option value="pushup">Push-ups</option>
      <option value="dip">Fondos</option>
      <option value="pullup">Pull-ups</option>
      <option value="squat">Squats</option>
    </select>
    <button id="startBtn">Activar cámara</button>
  </div>

  <div id="counter">Reps: 0</div>
  <div id="status">Estado: esperando cámara...</div>

  <video id="video" width="960" height="720" autoplay muted playsinline></video>
  <canvas id="output" width="960" height="720"></canvas>

<script>
/*
  Versión robusta con máquina de estados y buffers de frames.
  Objetivo: detectar correctamente el inicio de la rep y producir "no rep" con motivo.
*/

const video = document.getElementById('video');
const canvas = document.getElementById('output');
const ctx = canvas.getContext('2d');
const statusEl = document.getElementById('status');
const counterEl = document.getElementById('counter');
const exerciseSelect = document.getElementById('exercise');
const startBtn = document.getElementById('startBtn');

let detector;
let currentExercise = exerciseSelect.value;
let reps = 0;

// --- Máquina de estados ---
/* Estados: idle (no listo) -> ready (posición inicial estable) -> descending -> bottom -> ascending -> evaluate -> ready */
let state = 'idle';

// Buffers para suavizar y contar frames estables
const angleBuffer = [];
const bodyAngleBuffer = [];
const MAX_BUFFER = 8; // suavizado de ángulos (frames)

// Parámetros de estabilidad
const READY_FRAMES = 8;     // cuantos frames se requiere en posición inicial para considerar "ready"
const BOTTOM_FRAMES = 3;    // cuantos frames en el bottom para confirmar profundidad
const EXTEND_FRAMES = 5;    // cuantos frames extendido para confirmar extensión final

// Contadores temporales por fase
let readyCount = 0, bottomCount = 0, extendCount = 0;

// Último motivo "no rep" mostrado (evita spam)
let lastNoRep = '';

// Color overlay
let overlayGood = '#00FF88', overlayBad = '#FF5A5A';
let currentOverlay = overlayGood;

// Umbrales por ejercicio (configurables)
const THRESH = {
  pushup: { downAngle: 90, startThresh: 160, endThresh: 165, alignMin: 160 },
  dip:    { downAngle: 85, startThresh: 155, endThresh: 160, alignMin: 150 },
  pullup: { downAngle: 60, startThresh: 150, endThresh: 160, alignMin: 150 },
  squat:  { downAngle: 90, startThresh: 160, endThresh: 165, alignMin: 150 }
};

// helpers
function setStatus(text, bad=false){
  statusEl.textContent = text;
  currentOverlay = bad ? overlayBad : overlayGood;
  if(!bad) lastNoRep = '';
}

function setNoRep(reason){
  if(reason !== lastNoRep){
    statusEl.textContent = `❌ No rep — ${reason}`;
    currentOverlay = overlayBad;
    lastNoRep = reason;
  }
}

function updateCounter(){
  counterEl.textContent = `Reps: ${reps}`;
}

// Angular function (3 keypoints)
function getAngle(a,b,c){
  // guardas por si faltan
  if(!a || !b || !c) return null;
  const AB = {x: a.x - b.x, y: a.y - b.y};
  const CB = {x: c.x - b.x, y: c.y - b.y};
  const dot = AB.x*CB.x + AB.y*CB.y;
  const magAB = Math.sqrt(AB.x*AB.x + AB.y*AB.y);
  const magCB = Math.sqrt(CB.x*CB.x + CB.y*CB.y);
  if(magAB === 0 || magCB === 0) return null;
  let cos = dot / (magAB*magCB);
  if(cos > 1) cos = 1; if(cos < -1) cos = -1;
  return (Math.acos(cos) * 180 / Math.PI);
}

// Smooth buffer: push angle and return average
function smooth(angle, buffer){
  if(angle === null) return null;
  buffer.push(angle);
  if(buffer.length > MAX_BUFFER) buffer.shift();
  const sum = buffer.reduce((s,x)=>s+x,0);
  return sum / buffer.length;
}

// Draw keypoints and overlay lines
function drawPose(pose){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

  const kp = pose.keypoints;
  // keypoints circles
  kp.forEach(p=>{
    if(p.score > 0.35){
      ctx.beginPath();
      ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
      ctx.fillStyle = '#fff';
      ctx.fill();
    }
  });
}

// Determine if we have good keypoints for exercise
function haveRequiredKPs(kp, names){
  // names: array of index numbers to check
  for(const i of names){
    if(!kp[i] || kp[i].score < 0.35) return false;
  }
  return true;
}

// Main detection per frame with robust state machine
function processPose(pose){
  const kp = pose.keypoints;
  // keypoint indices MoveNet: 0 nose, 5 leftShoulder, 6 rightShoulder etc OR typical order:
  // MoveNet returns: 0: nose,1:leftEye,2:rightEye,3:leftEar,4:rightEar,5:leftShoulder,6:rightShoulder,7:leftElbow,8:rightElbow,9:leftWrist,10:rightWrist,11:leftHip,12:rightHip,13:leftKnee,14:rightKnee,15:leftAnkle,16:rightAnkle
  // BUT your earlier code used indices 11,13,15 as left side; to be safe, we'll attempt to use both-sides averaged for some measures.
  // For compatibility with prior code that used 11,13,15 as left shoulder/elbow/wrist (PoseNet ordering), we handle both conventions by mapping:
  const mapping = mapKeypoints(kp);

  const leftShoulder = mapping.leftShoulder, leftElbow = mapping.leftElbow, leftWrist = mapping.leftWrist;
  const rightShoulder = mapping.rightShoulder, rightElbow = mapping.rightElbow, rightWrist = mapping.rightWrist;
  const leftHip = mapping.leftHip, leftKnee = mapping.leftKnee, leftAnkle = mapping.leftAnkle;
  const rightHip = mapping.rightHip, rightKnee = mapping.rightKnee, rightAnkle = mapping.rightAnkle;
  const nose = mapping.nose;

  // choose side with higher confidence for arm/shoulder/elbow/wrist
  const shoulder = bestPoint(leftShoulder, rightShoulder);
  const elbow = bestPoint(leftElbow, rightElbow);
  const wrist = bestPoint(leftWrist, rightWrist);
  const hip = bestPoint(leftHip, rightHip);
  const knee = bestPoint(leftKnee, rightKnee);
  const ankle = bestPoint(leftAnkle, rightAnkle);

  // ensure keypoints exist roughly
  // For each exercise we define required keypoints:
  let required = [];
  if(currentExercise === 'pushup' || currentExercise === 'dip' || currentExercise === 'pullup'){
    required = [shoulder, elbow, wrist, hip, knee];
  } else if(currentExercise === 'squat'){
    required = [hip, knee, ankle];
  }

  // If required kps missing -> idle and inform
  if(required.some(p=>!p || p.score < 0.35)){
    state = 'idle';
    readyCount = bottomCount = extendCount = 0;
    setStatus('No se detectan puntos clave con suficiente confianza', true);
    return;
  }

  // Compute angles depending on exercise
  let mainAngle = null;     // angle of interest (elbow for push/dip/pull, knee for squat)
  let bodyLine = null;      // alignment (shoulder-hip-knee) for pushups etc

  if(currentExercise === 'pushup' || currentExercise === 'dip' || currentExercise === 'pullup'){
    mainAngle = getAngle(shoulder, elbow, wrist); // elbow angle
    bodyLine = getAngle(shoulder, hip, knee);
  } else if(currentExercise === 'squat'){
    mainAngle = getAngle(hip, knee, ankle); // knee angle
    bodyLine = getAngle(shoulder ? shoulder : hip, hip, knee); // rough trunk angle if available
  }

  if(mainAngle === null){
    // fallback
    state = 'idle';
    setStatus('Ángulo no calculable', true);
    return;
  }

  const smoothMain = smooth(mainAngle, angleBuffer);
  const smoothBody = bodyLine ? smooth(bodyLine, bodyAngleBuffer) : null;
  const t = THRESH[currentExercise];

  // ----------------- Máquina de estados robusta -----------------
  // IDLE: no posición inicial estable
  if(state === 'idle'){
    // Detectar posición inicial (extended) estable: mainAngle >= startThresh (con tolerancia)
    if(smoothMain >= (t.startThresh - 5)){
      readyCount++;
      if(readyCount >= READY_FRAMES){
        state = 'ready';
        setStatus('Ready — posición inicial confirmada', false);
        // reset counters
        bottomCount = extendCount = 0;
      }
    } else {
      readyCount = 0;
      // keep idle
    }
    drawFeedback(shoulder, elbow, wrist, hip, knee, ankle, smoothMain, smoothBody);
    return;
  }

  // READY: esperamos movimiento hacia abajo (descenso)
  if(state === 'ready'){
    if(smoothMain < t.startThresh - 8){ // empezó a moverse hacia abajo
      state = 'descending';
      setStatus('Descendiendo...', false);
      // initialize bottomCount
      bottomCount = 0;
    } else {
      // still ready
    }
    drawFeedback(shoulder, elbow, wrist, hip, knee, ankle, smoothMain, smoothBody);
    return;
  }

  // DESCENDING: buscamos alcanzar profundidad (downAngle)
  if(state === 'descending'){
    // if reaches bottom threshold
    if(smoothMain <= t.downAngle + 5){
      bottomCount++;
      if(bottomCount >= BOTTOM_FRAMES){
        state = 'bottom';
        setStatus('Bottom alcanzado', false);
      }
    } else {
      // if rises back above start threshold quickly -> shallow rep
      if(smoothMain > t.startThresh - 5){
        // movimiento fue superficial, no llegó a profundidad
        setNoRep('No bajó lo suficiente (superficial)');
        state = 'idle';
        readyCount = bottomCount = extendCount = 0;
      }
    }
    drawFeedback(shoulder, elbow, wrist, hip, knee, ankle, smoothMain, smoothBody);
    return;
  }

  // BOTTOM: esperamos que suba (ascenso)
  if(state === 'bottom'){
    if(smoothMain > t.endThresh - 5){
      extendCount++;
      if(extendCount >= EXTEND_FRAMES){
        // candidate for valid rep: now evaluate body alignment and other checks
        // bodyLine check if available
        if(smoothBody && smoothBody < t.alignMin){
          setNoRep('Cuerpo no alineado al finalizar (cadera/espalda)');
          // reset
          state = 'idle';
          readyCount = bottomCount = extendCount = 0;
        } else {
          // rep válida
          reps++;
          updateCounter();
          setStatus('✅ Rep válida', false);
          // small visual flash
          currentOverlay = overlayGood;
          // go to ready (require stability again)
          state = 'idle';
          readyCount = bottomCount = extendCount = 0;
        }
      } else {
        setStatus('Subiendo — verificando extensión...', false);
      }
    } else {
      // still in bottom or not yet ascending
      // If it stays too long without ascending, consider unstable bottom
      bottomCount = Math.min(bottomCount + 0, BOTTOM_FRAMES); // do nothing, keep time
    }
    drawFeedback(shoulder, elbow, wrist, hip, knee, ankle, smoothMain, smoothBody);
    return;
  }

  // fallback safety
  drawFeedback(shoulder, elbow, wrist, hip, knee, ankle, smoothMain, smoothBody);
}

// Choose best of left/right (higher score), return simplified kp object or null
function bestPoint(a,b){
  if(!a && !b) return null;
  if(!a) return b;
  if(!b) return a;
  return (a.score >= b.score) ? a : b;
}

// Map keypoints across different index orders - make robust
function mapKeypoints(kp){
  // Try to detect typical MoveNet order (17 keypoints)
  // We'll attempt to find left/right shoulders by name if available; otherwise fall back to indices similar to common models.
  // For portability, we pick indices that previous code used (11,13,15) but also handle alternate ordering (5,7,9,...).
  const n = kp[0] || null;
  // Try common PoseNet ordering indices
  const leftShoulder = kp[5] || kp[11] || null;
  const rightShoulder = kp[6] || kp[12] || null;
  const leftElbow = kp[7] || kp[13] || null;
  const rightElbow = kp[8] || kp[14] || null;
  const leftWrist = kp[9] || kp[15] || null;
  const rightWrist = kp[10] || kp[16] || null;
  const leftHip = kp[11] || kp[23] || null;
  const rightHip = kp[12] || kp[24] || null;
  const leftKnee = kp[13] || kp[25] || null;
  const rightKnee = kp[14] || kp[26] || null;
  const leftAnkle = kp[15] || kp[27] || null;
  const rightAnkle = kp[16] || kp[28] || null;

  return {
    nose: n,
    leftShoulder, rightShoulder,
    leftElbow, rightElbow,
    leftWrist, rightWrist,
    leftHip, rightHip,
    leftKnee, rightKnee,
    leftAnkle, rightAnkle
  };
}

// Draw overlay feedback lines + angles
function drawFeedback(shoulder, elbow, wrist, hip, knee, ankle, mainAngle, bodyAngle){
  // keep previous image
  // overlay color depending on lastNoRep
  ctx.lineWidth = 4;
  ctx.strokeStyle = lastNoRep ? overlayBad : overlayGood;
  ctx.fillStyle = lastNoRep ? overlayBad : overlayGood;

  // draw triad (main joint)
  if(shoulder && elbow && wrist){
    ctx.beginPath();
    ctx.moveTo(shoulder.x, shoulder.y);
    ctx.lineTo(elbow.x, elbow.y);
    ctx.lineTo(wrist.x, wrist.y);
    ctx.stroke();
    if(mainAngle !== null){
      ctx.font = '18px Arial';
      ctx.fillText(`${Math.round(mainAngle)}°`, elbow.x + 10, elbow.y - 10);
    }
  }

  // draw knee triad (for squat)
  if(hip && knee && ankle){
    ctx.beginPath();
    ctx.moveTo(hip.x, hip.y);
    ctx.lineTo(knee.x, knee.y);
    ctx.lineTo(ankle.x, ankle.y);
    ctx.stroke();
    if(mainAngle !== null && currentExercise === 'squat'){
      ctx.font = '18px Arial';
      ctx.fillText(`${Math.round(mainAngle)}°`, knee.x + 10, knee.y - 10);
    }
  }

  // show state text
  ctx.font = '16px Arial';
  ctx.fillStyle = '#fff';
  ctx.fillText(`Estado: ${state}`, 12, 20);
}

// --- Main loop & detector setup ---
exerciseSelect.addEventListener('change', ()=>{
  currentExercise = exerciseSelect.value;
  reps = 0; updateCounter();
  state = 'idle';
  angleBuffer.length = 0; bodyAngleBuffer.length = 0;
  readyCount = bottomCount = extendCount = 0;
  lastNoRep = '';
  setStatus('Ejercicio cambiado: ' + currentExercise, false);
});

startBtn.addEventListener('click', async ()=>{
  startBtn.disabled = true;
  await startCamera();
  await initDetector();
  run();
});

async function startCamera(){
  try{
    const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 960, height: 720 } });
    video.srcObject = stream;
    await new Promise(r=>video.onloadedmetadata=r);
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    setStatus('Cámara activa. Esperando pose...', false);
  }catch(e){
    console.error(e);
    setStatus('No se pudo acceder a la cámara', true);
  }
}

async function initDetector(){
  setStatus('Cargando detector...', false);
  detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, {
    modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING
  });
  setStatus('Detector activo', false);
}

async function run(){
  if(!detector) return;
  const poses = await detector.estimatePoses(video, { maxPoses: 1, flipHorizontal: false });
  if(poses && poses.length > 0){
    const pose = poses[0];
    drawPose(pose);
    processPose(pose);
  } else {
    // no pose detected
    setStatus('No se detecta pose', true);
    state = 'idle';
  }
  requestAnimationFrame(run);
}

function updateCounter(){ counterEl.textContent = `Reps: ${reps}`; }

</script>
</body>
</html>