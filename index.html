<script>
const video = document.getElementById('video');
const canvas = document.getElementById('output');
const ctx = canvas.getContext('2d');
const statusEl = document.getElementById('status');
const startBtn = document.getElementById('startBtn');
const exerciseSelect = document.getElementById('exerciseSelect');
const counterEl = document.getElementById('counter');

let detector;
let reps = 0, up = false; // 'up' ahora significa "ha pasado el umbral de movimiento"
let currentExercise = exerciseSelect.value;
let inPosition = false;
let feedbackMessage = "";
let feedbackTimer = null;

// Buffer simple para detectar quietud/estabilidad (usado para inPosition)
let movementBufferY = [];

// Mostrar feedback
function showFeedback(msg, duration=1500){
  if(feedbackMessage !== msg || statusEl.textContent === ""){
    feedbackMessage = msg;
    statusEl.textContent = msg;
    if(feedbackTimer) clearTimeout(feedbackTimer);
    if(duration > 0){
        feedbackTimer = setTimeout(()=>{ feedbackMessage=""; statusEl.textContent=""; }, duration);
    }
  }
}

// Cambiar ejercicio
exerciseSelect.addEventListener('change', ()=>{
  currentExercise = exerciseSelect.value;
  reps = 0;
  up = false;
  inPosition = false;
  movementBufferY = [];
  counterEl.textContent = "Reps: 0";
  const exerciseName = exerciseSelect.options[exerciseSelect.selectedIndex].text;
  showFeedback(`Ejercicio seleccionado: ${exerciseName}`, 2000);
});

startBtn.addEventListener('click', initCamera);

// Funci√≥n para calcular √°ngulo (CORRECTA)
function getAngle(a,b,c){
  if(!a || !b || !c) return 180;
  const AB = {x:b.x-a.x, y:b.y-a.y};
  const CB = {x:b.x-c.x, y:b.y-c.y};
  const dot = AB.x*CB.x + AB.y*CB.y;
  const magAB = Math.sqrt(AB.x**2 + AB.y**2);
  const magCB = Math.sqrt(CB.x**2 + CB.y**2);
  if(magAB*magCB === 0) return 180;
  let cosAngle = dot/(magAB*magCB);
  cosAngle = Math.max(-1, Math.min(1, cosAngle));
  return Math.round(Math.acos(cosAngle)*180/Math.PI);
}

// Estabilidad simple para detectar quietud (Ajustada a 10px)
function isStable(y, threshold=10, frames=30){
  if(y === undefined) return false;
  movementBufferY.push(y);
  if(movementBufferY.length>frames) movementBufferY.shift();
  if(movementBufferY.length < frames) return false;
  return (Math.max(...movementBufferY)-Math.min(...movementBufferY))<threshold;
}

// Inicializaci√≥n de C√°mara y Detector (se mantienen igual)
async function initCamera() {
    // ... (C√≥digo de initCamera) ...
    showFeedback("Iniciando c√°mara...");
    startBtn.disabled = true;
    let stream;
    try {
        stream = await navigator.mediaDevices.getUserMedia({
            video: { width: { ideal:1280 }, height: { ideal:720 }, facingMode: { exact: "environment" } },
            audio: false
        });
    } catch(e) {
        console.warn("No se pudo abrir c√°mara trasera, usando cualquier c√°mara disponible", e);
        stream = await navigator.mediaDevices.getUserMedia({ video:true, audio:false });
    }
    video.srcObject = stream;
    await video.play();
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    showFeedback("C√°mara activa ‚úÖ");
    await initDetector();
    detectPose();
}

async function initDetector() {
    showFeedback("Cargando detector...");
    detector = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, {
        modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING
    });
    showFeedback("Detector activo ‚úÖ", 1500);
}

// Funci√≥n principal de detecci√≥n de repeticiones con todos los ejercicios
function detectReps(kp){
  let reason = "";

  // Puntos clave de MoveNet
  const nose = kp[0], 
        shoulderL = kp[5], shoulderR = kp[6], 
        elbowL = kp[7], elbowR = kp[8], 
        wristL = kp[9], wristR = kp[10],
        hipL = kp[11], hipR = kp[12], 
        kneeL = kp[13], kneeR = kp[14], 
        ankleL = kp[15], ankleR = kp[16];

  // Definiciones comunes (usaremos Lado Izquierdo para Flexiones/Dips y Lado Derecho para Squats)
  const shoulder = shoulderR || shoulderL; // Intentamos usar R primero
  const elbow = elbowR || elbowL;
  const wrist = wristR || wristL;
  const hip = hipL || hipR;
  const knee = kneeL || kneeR;
  const ankle = ankleL || ankleR;

  // Actualizar Buffer de estabilidad (usando un punto central como la cadera)
  if(hip && hip.y) movementBufferY.push(hip.y);


  switch(currentExercise){
    case "pushup":
    case "dip":
      if(shoulder && elbow && wrist && hip){
        const angle = getAngle(shoulder, elbow, wrist);
        const yAvg = (shoulder.y + elbow.y)/2;
        const targetAngle = (currentExercise === "pushup") ? 105 : 95; // 105 para pushup, 95 para dip

        if(!inPosition){
          // Codo extendido (casi 180) Y Quietud.
          if(angle > 155 && isStable(yAvg, 10, 30)){
            inPosition = true;
            showFeedback(`üü¢ Listo para empezar ${currentExercise}`, 0);
          } else {
            showFeedback("Col√≥cate en posici√≥n inicial: brazos extendidos", 0);
          }
        } else {
          // Fase 1: Bajada (flexi√≥n de codo)
          if(angle <= targetAngle && !up) {
            up = true; // Se alcanz√≥ la profundidad m√≠nima
          }
          // Fase 2: Subida (extensi√≥n de codo) y conteo
          if(angle >= 155 && up){
            reps++;
            up=false;
            showFeedback("‚úÖ Repetici√≥n v√°lida");
          } else if(angle >= 155 && !up){
            // Error: Brazos rectos sin haber bajado suficiente
            reason = `No bajaste suficiente (necesitas <= ${targetAngle}¬∞)`;
            showFeedback(`‚ùå No rep: ${reason}`, 0);
          }
        }
      }
      break;

    case "squat":
      if(hip && knee && ankle && shoulder){
        const kneeAngle = getAngle(hip, knee, ankle);
        const yAvg = (hip.y+knee.y)/2;

        if(!inPosition){
          // Rodilla recta (casi 180) Y Quietud.
          if(kneeAngle > 155 && isStable(yAvg, 10, 30)){
            inPosition = true;
            showFeedback("üü¢ Listo para empezar squats", 0);
          } else {
            showFeedback("Col√≥cate en posici√≥n inicial: piernas rectas", 0);
          }
        } else {
          // Fase 1: Bajada (flexi√≥n de rodilla)
          if(kneeAngle <= 130 && !up) { // Umbral de profundidad 130 grados
            up = true;
          }
          // Fase 2: Subida (extensi√≥n de rodilla) y conteo
          if(kneeAngle >= 155 && up){
            reps++;
            up=false;
            showFeedback("‚úÖ Repetici√≥n v√°lida");
          } else if(kneeAngle >= 155 && !up){
            // Error: Piernas rectas sin haber bajado suficiente
            reason = `No bajaste suficiente (necesitas <= 130¬∞)`;
            showFeedback(`‚ùå No rep: ${reason}`, 0);
          }
        }
      }
      break;

    case "pullup":
      if(nose && wristL && wristR){
        const yHands = (wristL.y + wristR.y)/2;
        const yAvg = (nose.y + yHands)/2;

        if(!inPosition){
          // Nariz muy por debajo de las manos (colgado) Y Quietud.
          if(nose.y > yHands + 80 && isStable(yAvg, 10, 30)){
            inPosition = true;
            showFeedback("üü¢ Listo para empezar pull-ups", 0);
          } else {
            showFeedback("Col√≥cate en posici√≥n inicial: cuelga con brazos extendidos", 0);
          }
        } else {
          // Fase 1: Subida (Nariz sobre el nivel de las manos)
          if(nose.y <= yHands && !up) {
            up = true; // Se alcanz√≥ la altura m√≠nima
          }
          // Fase 2: Bajada (Regreso a colgado) y conteo
          if(nose.y >= yHands + 80 && up){
            reps++;
            up=false;
            showFeedback("‚úÖ Repetici√≥n v√°lida");
          } else if(nose.y >= yHands + 80 && !up){
            // Error: Brazo extendido sin haber subido suficiente
            reason = `No subiste suficiente (Nariz no alcanz√≥ el nivel de las manos)`;
            showFeedback(`‚ùå No rep: ${reason}`, 0);
          }
        }
      }
      break;
  }

  counterEl.textContent = `Reps: ${reps}`;
}

// ... (drawSkeleton y detectPose se mantienen igual) ...

function drawSkeleton(pose){
    const keypoints = pose.keypoints;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(video,0,0,canvas.width,canvas.height);

    const adjacentPairs = poseDetection.util.getAdjacentPairs(poseDetection.SupportedModels.MoveNet);
    ctx.lineWidth=2;
    ctx.strokeStyle="#00FF00";
    adjacentPairs.forEach(([i,j])=>{
        const kp1=keypoints[i], kp2=keypoints[j];
        if(kp1.score>0.5 && kp2.score>0.5){
            ctx.beginPath();
            ctx.moveTo(kp1.x,kp1.y);
            ctx.lineTo(kp2.x,kp2.y);
            ctx.stroke();
        }
    });

    keypoints.forEach(kp=>{
        if(kp.score>0.5){
            ctx.beginPath();
            ctx.arc(kp.x,kp.y,5,0,2*Math.PI);
            ctx.fillStyle="#00FF00";
            ctx.fill();
        }
    });

    if(keypoints.length > 0) detectReps(keypoints);
}

async function detectPose(){
    const detect = async ()=>{
        if(video.readyState>=2 && detector){
            const poses = await detector.estimatePoses(video);
            if(poses.length>0) drawSkeleton(poses[0]);
            else ctx.drawImage(video,0,0,canvas.width,canvas.height);
        }
        requestAnimationFrame(detect);
    };
    detect();
}
</script>
